# Module 02: Lane Keeping Assist System - êµ¬í˜„ ëª…ì„¸ì„œ

**ë²„ì „:** 1.0  
**ì‘ì„±ì¼:** 2026-01-30  
**ìƒíƒœ:** êµ¬í˜„ ë‹¨ê³„

---

## ğŸ“‹ ëª©ì°¨

1. [ê°œë°œ í™˜ê²½ ì„¤ì •](#1-ê°œë°œ-í™˜ê²½-ì„¤ì •)
2. [ë””ë ‰í„°ë¦¬ êµ¬ì¡°](#2-ë””ë ‰í„°ë¦¬-êµ¬ì¡°)
3. [í•µì‹¬ í´ë˜ìŠ¤ ëª…ì„¸](#3-í•µì‹¬-í´ë˜ìŠ¤-ëª…ì„¸)
4. [ì•Œê³ ë¦¬ì¦˜ ìƒì„¸](#4-ì•Œê³ ë¦¬ì¦˜-ìƒì„¸)
5. [ì„¤ì • íŒŒì¼ ëª…ì„¸](#5-ì„¤ì •-íŒŒì¼-ëª…ì„¸)
6. [í…ŒìŠ¤íŠ¸ ëª…ì„¸](#6-í…ŒìŠ¤íŠ¸-ëª…ì„¸)
7. [API ë¬¸ì„œ](#7-api-ë¬¸ì„œ)
8. [ì—ëŸ¬ ì²˜ë¦¬](#8-ì—ëŸ¬-ì²˜ë¦¬)

---

## 1. ê°œë°œ í™˜ê²½ ì„¤ì •

### 1.1 ì˜ì¡´ì„± ì„¤ì¹˜

```bash
# í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ
cd 02-lane-keeping-assist

# ê°€ìƒí™˜ê²½ ìƒì„± (ì„ íƒ)
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# ì˜ì¡´ì„± ì„¤ì¹˜
pip install -r requirements.txt
```

### 1.2 `requirements.txt`

```txt
# Core Dependencies
numpy>=1.24.0
scipy>=1.10.0
opencv-python>=4.8.0
shapely>=2.0.0
pyyaml>=6.0.0
loguru>=0.7.0

# Development Dependencies
pytest>=7.4.0
pytest-cov>=4.1.0
black>=23.0.0
flake8>=6.0.0
mypy>=1.5.0
pytest-benchmark>=4.0.0

# Optional (ì‹œê°í™”)
matplotlib>=3.7.0
seaborn>=0.12.0
```

---

## 2. ë””ë ‰í„°ë¦¬ êµ¬ì¡°

```
02-lane-keeping-assist/
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ setup.py
â”œâ”€â”€ main.py                      # Entry point
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ lkas_params.yaml         # ê¸°ë³¸ ì„¤ì •
â”‚   â””â”€â”€ lkas_params_aggressive.yaml  # ê³µê²©ì  ì„¤ì •
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ lkas.py                  # Main orchestrator
â”‚   â”‚
â”‚   â”œâ”€â”€ tracking/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ lane_tracker.py     # ì°¨ì„  ì¶”ì 
â”‚   â”‚   â””â”€â”€ geometry.py          # ê¸°í•˜í•™ ìœ í‹¸
â”‚   â”‚
â”‚   â”œâ”€â”€ detection/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ departure_detector.py  # ì´íƒˆ ê°ì§€
â”‚   â”‚
â”‚   â”œâ”€â”€ control/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ pid_controller.py   # PID ì œì–´
â”‚   â”‚   â””â”€â”€ safety_manager.py   # ì•ˆì „ ê´€ë¦¬
â”‚   â”‚
â”‚   â”œâ”€â”€ alert/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ warning_system.py   # ê²½ê³  ì‹œìŠ¤í…œ
â”‚   â”‚   â””â”€â”€ audio_manager.py    # ì˜¤ë””ì˜¤ ê´€ë¦¬
â”‚   â”‚
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ config_loader.py    # ì„¤ì • ë¡œë”
â”‚       â”œâ”€â”€ logger.py           # ë¡œê¹…
â”‚       â””â”€â”€ visualization.py    # ì‹œê°í™”
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_lane_tracker.py
â”‚   â”œâ”€â”€ test_departure_detector.py
â”‚   â”œâ”€â”€ test_pid_controller.py
â”‚   â”œâ”€â”€ test_warning_system.py
â”‚   â”œâ”€â”€ test_integration.py
â”‚   â””â”€â”€ fixtures/                # í…ŒìŠ¤íŠ¸ ë°ì´í„°
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ 01_ì•„í‚¤í…ì²˜_ì„¤ê³„ì„œ.md
â”‚   â”œâ”€â”€ 02_êµ¬í˜„_ëª…ì„¸ì„œ.md      # ì´ íŒŒì¼
â”‚   â”œâ”€â”€ 03_ê²€ì¦ì„œ.md
â”‚   â”œâ”€â”€ 04_êµ¬í˜„_ì¼ì¹˜ìœ¨_ë¶„ì„.md
â”‚   â””â”€â”€ 05_ì„±ëŠ¥_í‰ê°€.md
â”‚
â”œâ”€â”€ logs/                        # ëŸ°íƒ€ì„ ë¡œê·¸
â”œâ”€â”€ checkpoints/                 # í•™ìŠµëœ íŒŒë¼ë¯¸í„°
â””â”€â”€ results/                     # í…ŒìŠ¤íŠ¸ ê²°ê³¼
```

---

## 3. í•µì‹¬ í´ë˜ìŠ¤ ëª…ì„¸

### 3.1 `LaneTracker` (ì°¨ì„  ì¶”ì ê¸°)

**íŒŒì¼:** `src/tracking/lane_tracker.py`

```python
from typing import List, Tuple, Optional, Dict
import numpy as np
import cv2
from shapely.geometry import LineString, Point


class LaneTracker:
    """
    ì°¨ì„  ì¤‘ì‹¬ì„  ì¶”ì  ë° ì°¨ëŸ‰ ìœ„ì¹˜ ê³„ì‚°
    
    Attributes:
        smoothing_window (int): ìŠ¤ë¬´ë”© ìœˆë„ìš° í¬ê¸°
        min_confidence (float): ìµœì†Œ ì‹ ë¢°ë„ ì„ê³„ê°’
        vehicle_position (Tuple[float, float]): ì°¨ëŸ‰ ì¤‘ì‹¬ ìœ„ì¹˜ (ì´ë¯¸ì§€ ì¢Œí‘œ)
        image_shape (Tuple[int, int]): ì´ë¯¸ì§€ í¬ê¸° (H, W)
    """
    
    def __init__(
        self,
        smoothing_window: int = 5,
        min_confidence: float = 0.5,
        vehicle_position: Optional[Tuple[float, float]] = None,
        image_shape: Tuple[int, int] = (480, 640)
    ):
        """
        Parameters:
            smoothing_window: Moving average window size
            min_confidence: Minimum confidence threshold
            vehicle_position: Vehicle center position in image coordinates
                             Default: (image_height * 0.9, image_width / 2)
            image_shape: Image dimensions (height, width)
        """
        self.smoothing_window = smoothing_window
        self.min_confidence = min_confidence
        self.image_shape = image_shape
        
        if vehicle_position is None:
            # ê¸°ë³¸: ì´ë¯¸ì§€ í•˜ë‹¨ ì¤‘ì•™
            self.vehicle_position = (
                image_shape[0] * 0.9,
                image_shape[1] / 2
            )
        else:
            self.vehicle_position = vehicle_position
        
        # ë‚´ë¶€ ìƒíƒœ
        self._history: List[Dict] = []
        self._max_history = 30
    
    def track(
        self,
        lane_mask: np.ndarray,
        confidence: float
    ) -> Dict:
        """
        ì°¨ì„  ì¶”ì  ìˆ˜í–‰ (Mask ê¸°ë°˜)
        
        Parameters:
            lane_mask: Binary lane mask from Module 01 (H, W)
            confidence: Detection confidence (0.0 ~ 1.0)
        
        Returns:
            {
                "lane_center": List[Tuple[float, float]],
                "lateral_offset": float,  # meters
                "heading_error": float,   # degrees
                "curvature": float,       # 1/m
                "is_valid": bool,
                "confidence": float
            }
        """
        # 1. ìœ íš¨ì„± ê²€ì‚¬
        if confidence < self.min_confidence:
            return self._invalid_result("Low confidence")
        
        # 2. Mask â†’ Polyline ë³€í™˜
        lane_polyline = self._extract_polyline_from_mask(lane_mask)
        
        if lane_polyline is None or len(lane_polyline) < 3:
            return self._invalid_result("Polyline extraction failed")
        
        # 2. ìŠ¤ë¬´ë”©
        smoothed_polyline = self._smooth_polyline(lane_polyline)
        
        # 3. ì°¨ëŸ‰ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
        nearest_point, nearest_idx = self._find_nearest_point(
            smoothed_polyline,
            self.vehicle_position
        )
        
        # 4. íš¡ë°©í–¥ ì˜¤í”„ì…‹ ê³„ì‚° (í”½ì…€ â†’ ë¯¸í„°)
        lateral_offset_px = self._calculate_lateral_offset(
            self.vehicle_position,
            nearest_point,
            smoothed_polyline,
            nearest_idx
        )
        # ì›ê·¼ ë³´ì •ì„ ìœ„í•´ Y ì¢Œí‘œ ì „ë‹¬
        lateral_offset_m = self._pixel_to_meter(
            lateral_offset_px,
            y_position=nearest_point[1]
        )
        
        # 5. í—¤ë”© ì¶”ì •ê°’ ê³„ì‚° (IMU ì—†ì´ ê·¼ì‚¬)
        heading_error = self._calculate_heading_error(
            smoothed_polyline,
            nearest_idx
        )
        
        # 6. ê³¡ë¥  ê³„ì‚°
        curvature = self._calculate_curvature(
            smoothed_polyline,
            nearest_idx
        )
        
        result = {
            "lane_center": smoothed_polyline,
            "lateral_offset": lateral_offset_m,
            "heading_error": heading_error,
            "curvature": curvature,
            "is_valid": True,
            "confidence": confidence,
            "nearest_point": nearest_point,
            "nearest_idx": nearest_idx
        }
        
        # íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
        self._update_history(result)
        
        return result
    
    def _extract_polyline_from_mask(self, mask: np.ndarray) -> Optional[List[Tuple[float, float]]]:
        """
        Binary maskì—ì„œ ì°¨ì„  ì¤‘ì‹¬ì„  polyline ì¶”ì¶œ
        
        Algorithm:
            1. Skeleton ì¶”ì¶œ (Thinning)
            2. Contour ì°¾ê¸°
            3. ê°€ì¥ ê¸´ contour ì„ íƒ
            4. í•˜ë‹¨ë¶€í„° ìƒë‹¨ìœ¼ë¡œ ì •ë ¬
            5. Douglas-Peucker ê·¼ì‚¬ë¡œ ì  ê°œìˆ˜ ì¤„ì´ê¸°
        
        Parameters:
            mask: Binary mask (H, W) {0, 1}
        
        Returns:
            polyline: [(x, y), ...] or None
        """
        if mask.sum() == 0:
            return None
        
        # 1. Skeleton ì¶”ì¶œ (Zhang-Suen thinning)
        mask_uint8 = (mask * 255).astype(np.uint8)
        skeleton = cv2.ximgproc.thinning(mask_uint8)
        
        # 2. Contours ì°¾ê¸°
        contours, _ = cv2.findContours(
            skeleton,
            cv2.RETR_EXTERNAL,
            cv2.CHAIN_APPROX_SIMPLE
        )
        
        if len(contours) == 0:
            return None
        
        # 3. ê°€ì¥ ê¸´ contour ì„ íƒ
        longest_contour = max(contours, key=cv2.contourArea)
        
        # 4. Contour â†’ polyline
        polyline = longest_contour.squeeze().tolist()
        
        # ë‹¨ì¼ ì ì´ë©´ ì‹¤íŒ¨
        if not isinstance(polyline[0], (list, tuple)):
            return None
        
        # 5. Y ì¢Œí‘œ ê¸°ì¤€ ì •ë ¬ (í•˜ë‹¨ â†’ ìƒë‹¨)
        polyline = sorted(polyline, key=lambda p: p[1], reverse=True)
        
        # 6. Douglas-Peucker ê·¼ì‚¬ (ì  ê°œìˆ˜ ì¤„ì´ê¸°)
        polyline_np = np.array(polyline, dtype=np.float32).reshape(-1, 1, 2)
        epsilon = 2.0  # ê·¼ì‚¬ ì •í™•ë„
        approx = cv2.approxPolyDP(polyline_np, epsilon, closed=False)
        polyline_approx = approx.squeeze().tolist()
        
        # ë¦¬ìŠ¤íŠ¸ í˜•ì‹ ë³´ì¥
        if not isinstance(polyline_approx[0], (list, tuple)):
            polyline_approx = [tuple(polyline_approx)]
        
        return [tuple(p) for p in polyline_approx]
    
    def _smooth_polyline(
        self,
        polyline: List[Tuple[float, float]]
    ) -> List[Tuple[float, float]]:
        """
        Moving averageë¡œ polyline ìŠ¤ë¬´ë”©
        """
        if len(polyline) < self.smoothing_window:
            return polyline
        
        smoothed = []
        half_window = self.smoothing_window // 2
        
        for i in range(len(polyline)):
            start = max(0, i - half_window)
            end = min(len(polyline), i + half_window + 1)
            
            window = polyline[start:end]
            avg_x = np.mean([p[0] for p in window])
            avg_y = np.mean([p[1] for p in window])
            smoothed.append((avg_x, avg_y))
        
        return smoothed
    
    def _find_nearest_point(
        self,
        polyline: List[Tuple[float, float]],
        reference: Tuple[float, float]
    ) -> Tuple[Tuple[float, float], int]:
        """
        Polylineì—ì„œ referenceì— ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
        
        Returns:
            (nearest_point, index)
        """
        min_dist = float('inf')
        nearest_point = polyline[0]
        nearest_idx = 0
        
        for i, point in enumerate(polyline):
            dist = np.hypot(point[0] - reference[0], point[1] - reference[1])
            if dist < min_dist:
                min_dist = dist
                nearest_point = point
                nearest_idx = i
        
        return nearest_point, nearest_idx
    
    def _calculate_lateral_offset(
        self,
        vehicle_pos: Tuple[float, float],
        nearest_point: Tuple[float, float],
        polyline: List[Tuple[float, float]],
        nearest_idx: int
    ) -> float:
        """
        íš¡ë°©í–¥ ì˜¤í”„ì…‹ ê³„ì‚° (í”½ì…€ ë‹¨ìœ„)
        
        ì–‘ìˆ˜: ì°¨ì„  ì¤‘ì‹¬ ì˜¤ë¥¸ìª½
        ìŒìˆ˜: ì°¨ì„  ì¤‘ì‹¬ ì™¼ìª½
        """
        # ë²¡í„°: nearest_point â†’ vehicle_pos
        dx = vehicle_pos[0] - nearest_point[0]
        dy = vehicle_pos[1] - nearest_point[1]
        
        # ì°¨ì„  ë°©í–¥ ë²¡í„° (tangent)
        if nearest_idx < len(polyline) - 1:
            next_point = polyline[nearest_idx + 1]
        else:
            next_point = polyline[nearest_idx]
        
        tx = next_point[0] - nearest_point[0]
        ty = next_point[1] - nearest_point[1]
        t_norm = np.hypot(tx, ty)
        
        if t_norm < 1e-6:
            return 0.0
        
        # ì •ê·œí™”
        tx /= t_norm
        ty /= t_norm
        
        # Cross product (2D)ë¡œ ë¶€í˜¸ ê²°ì •
        # lateral_offset = dx * (-ty) + dy * tx
        lateral_offset = dx * (-ty) + dy * tx
        
        return lateral_offset
    
    def _calculate_heading_error(
        self,
        polyline: List[Tuple[float, float]],
        nearest_idx: int
    ) -> float:
        """
        í—¤ë”© ì¶”ì •ê°’ ê³„ì‚° (IMU ì—†ì´ ê·¼ì‚¬)
        
        Note:
            - IMU/Gyro ì—†ì´ëŠ” ì •í™•í•œ ì°¨ëŸ‰ headingì„ ì•Œ ìˆ˜ ì—†ìŒ
            - Polylineì˜ ê³¡ë¥  ë³€í™”ìœ¨ë¡œ heading ë³€í™” ì¶”ì •
            - ì •í™•ë„: Â±10ë„ ì˜¤ì°¨ ê°€ëŠ¥
        
        Method:
            ì—°ì†ëœ polyline ì„¸ê·¸ë¨¼íŠ¸ì˜ ê°ë„ ë³€í™”ë¡œ ì¶”ì •
            - ì§ì„ : ê°ë„ ë³€í™” ì‘ìŒ â†’ heading_error â‰ˆ 0
            - ì¢Œì»¤ë¸Œ: ê°ë„ ì¦ê°€ â†’ heading_error > 0
            - ìš°ì»¤ë¸Œ: ê°ë„ ê°ì†Œ â†’ heading_error < 0
        
        Returns:
            heading_estimate: ì¶”ì • í—¤ë”© ë³€í™” (degrees)
        """
        # ê²½ê³„ ì²´í¬
        if nearest_idx < 2 or nearest_idx >= len(polyline) - 2:
            return 0.0
        
        # ì´ì „ ì„¸ê·¸ë¨¼íŠ¸ ê°ë„
        p_prev = polyline[nearest_idx - 2]
        p_curr = polyline[nearest_idx]
        angle_prev = np.arctan2(
            p_curr[1] - p_prev[1],
            p_curr[0] - p_prev[0]
        )
        
        # ë‹¤ìŒ ì„¸ê·¸ë¨¼íŠ¸ ê°ë„
        p_next = polyline[nearest_idx + 2]
        angle_next = np.arctan2(
            p_next[1] - p_curr[1],
            p_next[0] - p_curr[0]
        )
        
        # ê°ë„ ë³€í™” (polylineì˜ ê³¡ë¥  ë°©í–¥)
        heading_change = angle_next - angle_prev
        
        # -Ï€ ~ Ï€ ë²”ìœ„ë¡œ ì •ê·œí™”
        heading_change = np.arctan2(np.sin(heading_change), np.cos(heading_change))
        
        # degreeë¡œ ë³€í™˜
        heading_deg = np.degrees(heading_change)
        
        return heading_deg
    
    def _calculate_curvature(
        self,
        polyline: List[Tuple[float, float]],
        center_idx: int,
        window: int = 5
    ) -> float:
        """
        ê³¡ë¥  ê³„ì‚° (1/m)
        
        3ì ì„ ì´ìš©í•œ ê³¡ë¥  ê·¼ì‚¬
        """
        if center_idx < window or center_idx >= len(polyline) - window:
            return 0.0
        
        # 3ê°œ ì  ì„ íƒ
        p1 = polyline[center_idx - window]
        p2 = polyline[center_idx]
        p3 = polyline[center_idx + window]
        
        # ì‚¼ê°í˜• ë„“ì´ë¡œ ê³¡ë¥  ê·¼ì‚¬
        # ì°¸ê³ : https://en.wikipedia.org/wiki/Menger_curvature
        a = np.hypot(p2[0] - p1[0], p2[1] - p1[1])
        b = np.hypot(p3[0] - p2[0], p3[1] - p2[1])
        c = np.hypot(p3[0] - p1[0], p3[1] - p1[1])
        
        if a < 1e-6 or b < 1e-6 or c < 1e-6:
            return 0.0
        
        # Heron's formulaë¡œ ë„“ì´ ê³„ì‚°
        s = (a + b + c) / 2
        area = np.sqrt(max(0, s * (s - a) * (s - b) * (s - c)))
        
        # ê³¡ë¥  = 4 * Area / (a * b * c)
        curvature_px = 4 * area / (a * b * c + 1e-10)
        
        # í”½ì…€ â†’ ë¯¸í„° ë³€í™˜ (center_idx ìœ„ì¹˜ ê¸°ì¤€)
        y_pos = polyline[center_idx][1]
        curvature_m = curvature_px * self._get_pixel_to_meter_ratio(y_pos)
        
        return curvature_m
    
    def _pixel_to_meter(self, pixel_value: float, y_position: float) -> float:
        """
        í”½ì…€ ê°’ì„ ë¯¸í„°ë¡œ ë³€í™˜ (ì›ê·¼ ë³´ì • í¬í•¨)
        
        Parameters:
            pixel_value: í”½ì…€ ê±°ë¦¬
            y_position: ì´ë¯¸ì§€ ë‚´ Y ì¢Œí‘œ (ì›ê·¼ ë³´ì •ìš©)
        
        Returns:
            meter_value: ë¯¸í„° ê±°ë¦¬ (ê·¼ì‚¬ê°’)
        
        Warning:
            - ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì—†ì´ ê²½í—˜ì  ê·¼ì‚¬ ì‚¬ìš©
            - ì •í™•ë„: Â±30% ì˜¤ì°¨ ê°€ëŠ¥
            - ê¶Œì¥: Camera calibration + IPM ì‚¬ìš©
        """
        # RC íŠ¸ë™ í™˜ê²½ ê¸°ì¤€
        track_width_m = 0.35  # meters
        image_height = self.image_shape[0]
        
        # ì›ê·¼ ë³´ì • ê³„ìˆ˜ (ê²½í—˜ì )
        # ì´ë¯¸ì§€ í•˜ë‹¨(ê°€ê¹Œì›€): scale = 1.0
        # ì´ë¯¸ì§€ ìƒë‹¨(ë©€ë¦¬): scale = 3.0
        y_normalized = y_position / image_height
        perspective_scale = 1.0 + 2.0 * (1.0 - y_normalized)
        
        # ê¸°ì¤€ í”½ì…€-ë¯¸í„° ë¹„ìœ¨ (ì´ë¯¸ì§€ í•˜ë‹¨ ê¸°ì¤€)
        # ê°€ì •: ì´ë¯¸ì§€ í•˜ë‹¨ì—ì„œ íŠ¸ë™ì´ ì´ë¯¸ì§€ í­ì˜ 60% ì°¨ì§€
        track_width_px_bottom = self.image_shape[1] * 0.6  # 384 pixels
        base_ratio = track_width_m / track_width_px_bottom  # 0.35 / 384 = 0.00091 m/px
        
        # ì›ê·¼ ë³´ì • ì ìš©
        ratio = base_ratio * perspective_scale
        
        return pixel_value * ratio
    
    def _get_pixel_to_meter_ratio(self, y_position: float = None) -> float:
        """
        í”½ì…€-ë¯¸í„° ë³€í™˜ ë¹„ìœ¨ (ìœ„ì¹˜ ì˜ì¡´ì )
        
        Parameters:
            y_position: Y ì¢Œí‘œ (Noneì´ë©´ ì´ë¯¸ì§€ í•˜ë‹¨ ê¸°ì¤€)
        """
        if y_position is None:
            y_position = self.image_shape[0] * 0.9  # ê¸°ë³¸: í•˜ë‹¨
        
        track_width_m = 0.35
        y_normalized = y_position / self.image_shape[0]
        perspective_scale = 1.0 + 2.0 * (1.0 - y_normalized)
        
        track_width_px_bottom = self.image_shape[1] * 0.6
        base_ratio = track_width_m / track_width_px_bottom
        
        return base_ratio * perspective_scale
    
    def _invalid_result(self, reason: str) -> Dict:
        """Invalid ê²°ê³¼ ë°˜í™˜"""
        return {
            "lane_center": [],
            "lateral_offset": 0.0,
            "heading_error": 0.0,
            "curvature": 0.0,
            "is_valid": False,
            "confidence": 0.0,
            "reason": reason
        }
    
    def _update_history(self, result: Dict):
        """íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸"""
        self._history.append(result)
        if len(self._history) > self._max_history:
            self._history.pop(0)
    
    def get_history(self) -> List[Dict]:
        """íˆìŠ¤í† ë¦¬ ë°˜í™˜"""
        return self._history.copy()
    
    def reset(self):
        """ìƒíƒœ ì´ˆê¸°í™”"""
        self._history.clear()
```

### 3.2 `DepartureDetector` (ì´íƒˆ ê°ì§€ê¸°)

**íŒŒì¼:** `src/detection/departure_detector.py`

```python
from typing import Dict, Tuple
import numpy as np
from dataclasses import dataclass


@dataclass
class DepartureThresholds:
    """ì´íƒˆ íŒì • ì„ê³„ê°’ (RC íŠ¸ë™ ê¸°ì¤€)"""
    level_2_offset: float = 0.08  # meters (8cm)
    level_3_offset: float = 0.12  # 12cm
    level_4_offset: float = 0.15  # 15cm
    level_5_offset: float = 0.18  # 18cm (íŠ¸ë™ ê²½ê³„)
    
    level_2_heading: float = 10.0  # degrees
    level_3_heading: float = 20.0
    level_4_heading: float = 30.0
    level_5_heading: float = 40.0


class DepartureDetector:
    """
    ì°¨ì„  ì´íƒˆ ê°ì§€ ë° ìœ„í—˜ë„ í‰ê°€ (RC Car)
    
    Risk Levels:
        0: Safe - ì •ìƒ ì£¼í–‰ (< 5cm offset)
        1: Normal - ì•½ê°„ ë²—ì–´ë‚¨ (5-8cm), ëª¨ë‹ˆí„°ë§
        2: Caution - ì£¼ì˜ í•„ìš” (8-12cm), ì‹œê° ê²½ê³ 
        3: Warning - ê²½ê³  í•„ìš” (12-15cm), ì²­ê° ê²½ê³ 
        4: Critical - ìœ„í—˜ (15-18cm), ê°œì… ì¤€ë¹„
        5: Emergency - ê¸´ê¸‰ (> 18cm), ì¦‰ì‹œ ê°œì…
    
    Note:
        RC íŠ¸ë™ í­ = 35cmì´ë¯€ë¡œ 18cm ì´íƒˆ = íŠ¸ë™ ê²½ê³„ ë„ë‹¬
    """
    
    def __init__(
        self,
        thresholds: DepartureThresholds = None,
        track_width: float = 0.35  # RC track width in meters
    ):
        """
        Parameters:
            thresholds: ì´íƒˆ íŒì • ì„ê³„ê°’
            lane_width: ì°¨ì„  í­ (meters)
        """
        self.thresholds = thresholds or DepartureThresholds()
        self.track_width = track_width
        
        # ìƒíƒœ
        self._prev_risk_level = 0
        self._risk_start_time = None
    
    def detect(
        self,
        lateral_offset: float,
        heading_error: float,
        vehicle_speed: float,
        timestamp: float
    ) -> Dict:
        """
        ì´íƒˆ ê°ì§€ ìˆ˜í–‰
        
        Parameters:
            lateral_offset: íš¡ë°©í–¥ ì˜¤í”„ì…‹ (meters)
            heading_error: í—¤ë”© ì˜¤ì°¨ (degrees)
            vehicle_speed: ì°¨ëŸ‰ ì†ë„ (km/h)
            timestamp: í˜„ì¬ ì‹œê° (Unix timestamp)
        
        Returns:
            {
                "is_departing": bool,
                "risk_level": int,  # 0-5
                "time_to_crossing": float,  # seconds
                "departure_side": str,  # "left", "right", "none"
                "confidence": float
            }
        """
        # 1. ìœ„í—˜ë„ ë ˆë²¨ ê²°ì •
        risk_level = self._calculate_risk_level(
            abs(lateral_offset),
            abs(heading_error)
        )
        
        # 2. ì´íƒˆ ë°©í–¥
        departure_side = self._determine_side(lateral_offset)
        
        # 3. Time To Crossing ê³„ì‚°
        ttc = self._calculate_ttc(
            lateral_offset,
            heading_error,
            vehicle_speed
        )
        
        # 4. ì´íƒˆ ì—¬ë¶€
        is_departing = risk_level >= 2
        
        # 5. ì‹ ë¢°ë„ (ê°„ë‹¨í•œ íœ´ë¦¬ìŠ¤í‹±)
        confidence = min(1.0, risk_level / 5.0)
        
        result = {
            "is_departing": is_departing,
            "risk_level": risk_level,
            "time_to_crossing": ttc,
            "departure_side": departure_side,
            "confidence": confidence,
            "timestamp": timestamp
        }
        
        # ìƒíƒœ ì—…ë°ì´íŠ¸
        self._update_state(risk_level, timestamp)
        
        return result
    
    def _calculate_risk_level(
        self,
        abs_offset: float,
        abs_heading: float
    ) -> int:
        """
        ìœ„í—˜ë„ ë ˆë²¨ ê³„ì‚°
        
        offsetê³¼ heading ì¤‘ ë” ë†’ì€ ë ˆë²¨ ì„ íƒ
        """
        # Offset ê¸°ë°˜ ë ˆë²¨
        if abs_offset >= self.thresholds.level_5_offset:
            offset_level = 5
        elif abs_offset >= self.thresholds.level_4_offset:
            offset_level = 4
        elif abs_offset >= self.thresholds.level_3_offset:
            offset_level = 3
        elif abs_offset >= self.thresholds.level_2_offset:
            offset_level = 2
        else:
            offset_level = 0
        
        # Heading ê¸°ë°˜ ë ˆë²¨
        if abs_heading >= self.thresholds.level_5_heading:
            heading_level = 5
        elif abs_heading >= self.thresholds.level_4_heading:
            heading_level = 4
        elif abs_heading >= self.thresholds.level_3_heading:
            heading_level = 3
        elif abs_heading >= self.thresholds.level_2_heading:
            heading_level = 2
        else:
            heading_level = 0
        
        # ìµœëŒ€ê°’ ì„ íƒ
        return max(offset_level, heading_level)
    
    def _determine_side(self, lateral_offset: float) -> str:
        """ì´íƒˆ ë°©í–¥ ê²°ì •"""
        if lateral_offset > 0.1:
            return "right"
        elif lateral_offset < -0.1:
            return "left"
        else:
            return "none"
    
    def _calculate_ttc(
        self,
        lateral_offset: float,
        heading_error: float,
        vehicle_speed: float
    ) -> float:
        """
        Time To Crossing ê³„ì‚°
        
        ì°¨ì„  ê²½ê³„ê¹Œì§€ ë„ë‹¬í•˜ëŠ” ì‹œê°„ ì¶”ì •
        """
        # ì†ë„ê°€ ë„ˆë¬´ ë‚®ìœ¼ë©´ TTC ë¬´í•œëŒ€
        if vehicle_speed < 5.0:  # 5 km/h
            return float('inf')
        
        # íŠ¸ë™ ê²½ê³„ê¹Œì§€ ë‚¨ì€ ê±°ë¦¬
        remaining_distance = (self.track_width / 2) - abs(lateral_offset)
        
        if remaining_distance <= 0:
            return 0.0
        
        # íš¡ë°©í–¥ ì†ë„ ì¶”ì • (ê°„ë‹¨í•œ ê·¼ì‚¬)
        # lateral_velocity â‰ˆ vehicle_speed * sin(heading_error)
        vehicle_speed_ms = vehicle_speed / 3.6  # km/h â†’ m/s
        heading_rad = np.radians(heading_error)
        lateral_velocity = abs(vehicle_speed_ms * np.sin(heading_rad))
        
        if lateral_velocity < 0.01:
            return float('inf')
        
        ttc = remaining_distance / lateral_velocity
        
        return min(ttc, 10.0)  # ìµœëŒ€ 10ì´ˆë¡œ ì œí•œ
    
    def _update_state(self, risk_level: int, timestamp: float):
        """ë‚´ë¶€ ìƒíƒœ ì—…ë°ì´íŠ¸"""
        if risk_level != self._prev_risk_level:
            self._risk_start_time = timestamp
        
        self._prev_risk_level = risk_level
    
    def reset(self):
        """ìƒíƒœ ì´ˆê¸°í™”"""
        self._prev_risk_level = 0
        self._risk_start_time = None
```

### 3.3 `PIDController` (PID ì œì–´ê¸°)

**íŒŒì¼:** `src/control/pid_controller.py`

```python
from typing import Optional
import numpy as np
from dataclasses import dataclass


@dataclass
class PIDParams:
    """PID íŒŒë¼ë¯¸í„° (RC Car ì´ˆê¸° ì¶”ì •ê°’)"""
    kp: float = 2.0  # ê°•í•œ ë¹„ë¡€ ì œì–´ (ì‘ì€ ìŠ¤ì¼€ì¼)
    ki: float = 0.2
    kd: float = 0.5  # ê°•í•œ ë¯¸ë¶„ (ë¹ ë¥¸ ë³€í™” ëŒ€ì‘)
    k_heading: float = 0.2  # heading ê·¼ì‚¬ê°’ì´ë¯€ë¡œ ë‚®ì€ ê°€ì¤‘ì¹˜
    
    max_steering_angle: float = 45.0  # degrees (RC ì„œë³´ ë²”ìœ„)
    max_steering_rate: float = 100.0  # deg/s (RC ì„œë³´ëŠ” ë¹ ë¦„)
    
    windup_limit: float = 5.0  # ì‘ì€ ìŠ¤ì¼€ì¼ì— ë§ì¶¤
    
    wheelbase: float = 0.25  # meters (PiRacer)


class PIDController:
    """
    PID ê¸°ë°˜ ì¡°í–¥ ì œì–´ê¸°
    
    Control Law:
        u(t) = Kp * e(t) + Ki * âˆ«e(t)dt + Kd * de(t)/dt
        
        where:
            e(t) = lateral_offset + K_heading * heading_error
    """
    
    def __init__(self, params: PIDParams = None, dt: float = 0.05):
        """
        Parameters:
            params: PID íŒŒë¼ë¯¸í„°
            dt: ì œì–´ ì£¼ê¸° (seconds)
        """
        self.params = params or PIDParams()
        self.dt = dt
        
        # ë‚´ë¶€ ìƒíƒœ
        self._integral = 0.0
        self._prev_error = 0.0
        self._prev_steering = 0.0
    
    def compute(
        self,
        lateral_offset: float,
        heading_estimate: float,
        curvature: float = 0.0
    ) -> float:
        """
        ì œì–´ ì‹ í˜¸ ê³„ì‚°
        
        Parameters:
            lateral_offset: íš¡ë°©í–¥ ì˜¤í”„ì…‹ (meters)
            heading_estimate: í—¤ë”© ì¶”ì •ê°’ (degrees, IMU ì—†ì´ ê·¼ì‚¬)
            curvature: ì°¨ì„  ê³¡ë¥  (1/m)
        
        Returns:
            steering_angle: ì¡°í–¥ê° (degrees)
        
        Note:
            heading_estimateëŠ” IMU ì—†ì´ polyline ë³€í™”ìœ¨ë¡œ ì¶”ì •í•˜ë¯€ë¡œ
            ì •í™•ë„ê°€ ë‚®ìŒ (Â±10ë„ ì˜¤ì°¨). k_headingì„ ë‚®ê²Œ ì„¤ì •.
        """
        # 1. í†µí•© ì—ëŸ¬ ê³„ì‚°
        # heading_estimateëŠ” ë¶€ì •í™•í•˜ë¯€ë¡œ ë‚®ì€ ê°€ì¤‘ì¹˜ ì ìš©
        error = lateral_offset + self.params.k_heading * heading_estimate
        
        # 2. PID í•­ ê³„ì‚°
        # P term
        p_term = self.params.kp * error
        
        # I term (with anti-windup)
        self._integral += error * self.dt
        self._integral = np.clip(
            self._integral,
            -self.params.windup_limit,
            self.params.windup_limit
        )
        i_term = self.params.ki * self._integral
        
        # D term
        derivative = (error - self._prev_error) / self.dt
        d_term = self.params.kd * derivative
        
        # 3. Feedforward term (ê³¡ë¥  ë³´ìƒ)
        # Bicycle model: tan(Î´) = L * Îº (Î´ = steering, L = wheelbase, Îº = curvature)
        if abs(curvature) < 1e-6:
            ff_term = 0.0
        else:
            ff_term = np.degrees(np.arctan(self.params.wheelbase * curvature))
            # RCì¹´ ìŠ¤ì¼€ì¼ì—ì„œ ë„ˆë¬´ ê·¹ë‹¨ì ì¸ ê°’ ë°©ì§€
            ff_term = np.clip(ff_term, -15.0, 15.0)
        
        # 4. ì´ ì œì–´ ì‹ í˜¸
        steering_raw = p_term + i_term + d_term + ff_term
        
        # 5. ì œì•½ ì¡°ê±´ ì ìš©
        # ìµœëŒ€ ì¡°í–¥ê° ì œí•œ
        steering_clamped = np.clip(
            steering_raw,
            -self.params.max_steering_angle,
            self.params.max_steering_angle
        )
        
        # ìµœëŒ€ ì¡°í–¥ ì†ë„ ì œí•œ
        steering_rate = (steering_clamped - self._prev_steering) / self.dt
        if abs(steering_rate) > self.params.max_steering_rate:
            steering_rate = np.sign(steering_rate) * self.params.max_steering_rate
            steering_clamped = self._prev_steering + steering_rate * self.dt
        
        # 6. ìƒíƒœ ì—…ë°ì´íŠ¸
        self._prev_error = error
        self._prev_steering = steering_clamped
        
        return steering_clamped
    
    def reset(self):
        """ì œì–´ê¸° ìƒíƒœ ì´ˆê¸°í™”"""
        self._integral = 0.0
        self._prev_error = 0.0
        self._prev_steering = 0.0
    
    def update_params(self, **kwargs):
        """íŒŒë¼ë¯¸í„° ë™ì  ì—…ë°ì´íŠ¸"""
        for key, value in kwargs.items():
            if hasattr(self.params, key):
                setattr(self.params, key, value)
```

---

*(ê³„ì† ì‘ì„± ì¤‘... íŒŒì¼ì´ ë„ˆë¬´ ê¸¸ì–´ì ¸ì„œ ì¼ë¶€ë§Œ ë³´ì—¬ë“œë¦½ë‹ˆë‹¤)*

ì´ì œ ê²€ì¦ì„œë„ ì‘ì„±í• ê¹Œìš”? ì•„ë‹ˆë©´ ë¨¼ì € ì´ êµ¬í˜„ ëª…ì„¸ì„œë¥¼ ì™„ì„±í•˜ê³  ì‹¤ì œ ì½”ë“œ êµ¬í˜„ì„ ì‹œì‘í• ê¹Œìš”?