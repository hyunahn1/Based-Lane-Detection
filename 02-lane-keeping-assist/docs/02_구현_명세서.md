# Module 02: Lane Keeping Assist System - êµ¬í˜„ ëª…ì„¸ì„œ

**ë²„ì „:** 1.0  
**ì‘ì„±ì¼:** 2026-01-30  
**ìƒíƒœ:** êµ¬í˜„ ë‹¨ê³„

---

## ğŸ“‹ ëª©ì°¨

1. [ê°œë°œ í™˜ê²½ ì„¤ì •](#1-ê°œë°œ-í™˜ê²½-ì„¤ì •)
2. [ë””ë ‰í„°ë¦¬ êµ¬ì¡°](#2-ë””ë ‰í„°ë¦¬-êµ¬ì¡°)
3. [í•µì‹¬ í´ë˜ìŠ¤ ëª…ì„¸](#3-í•µì‹¬-í´ë˜ìŠ¤-ëª…ì„¸)
4. [ì•Œê³ ë¦¬ì¦˜ ìƒì„¸](#4-ì•Œê³ ë¦¬ì¦˜-ìƒì„¸)
5. [ì„¤ì • íŒŒì¼ ëª…ì„¸](#5-ì„¤ì •-íŒŒì¼-ëª…ì„¸)
6. [í…ŒìŠ¤íŠ¸ ëª…ì„¸](#6-í…ŒìŠ¤íŠ¸-ëª…ì„¸)
7. [API ë¬¸ì„œ](#7-api-ë¬¸ì„œ)
8. [ì—ëŸ¬ ì²˜ë¦¬](#8-ì—ëŸ¬-ì²˜ë¦¬)

---

## 1. ê°œë°œ í™˜ê²½ ì„¤ì •

### 1.1 ì˜ì¡´ì„± ì„¤ì¹˜

```bash
# í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ
cd 02-lane-keeping-assist

# ê°€ìƒí™˜ê²½ ìƒì„± (ì„ íƒ)
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# ì˜ì¡´ì„± ì„¤ì¹˜
pip install -r requirements.txt
```

### 1.2 `requirements.txt`

```txt
# Core Dependencies
numpy>=1.24.0
scipy>=1.10.0
opencv-python>=4.8.0
shapely>=2.0.0
pyyaml>=6.0.0
loguru>=0.7.0

# Development Dependencies
pytest>=7.4.0
pytest-cov>=4.1.0
black>=23.0.0
flake8>=6.0.0
mypy>=1.5.0
pytest-benchmark>=4.0.0

# Optional (ì‹œê°í™”)
matplotlib>=3.7.0
seaborn>=0.12.0
```

---

## 2. ë””ë ‰í„°ë¦¬ êµ¬ì¡°

```
02-lane-keeping-assist/
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ setup.py
â”œâ”€â”€ main.py                      # Entry point
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ lkas_params.yaml         # ê¸°ë³¸ ì„¤ì •
â”‚   â””â”€â”€ lkas_params_aggressive.yaml  # ê³µê²©ì  ì„¤ì •
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ lkas.py                  # Main orchestrator
â”‚   â”‚
â”‚   â”œâ”€â”€ tracking/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ lane_tracker.py     # ì°¨ì„  ì¶”ì 
â”‚   â”‚   â””â”€â”€ geometry.py          # ê¸°í•˜í•™ ìœ í‹¸
â”‚   â”‚
â”‚   â”œâ”€â”€ detection/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ departure_detector.py  # ì´íƒˆ ê°ì§€
â”‚   â”‚
â”‚   â”œâ”€â”€ control/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ pid_controller.py   # PID ì œì–´
â”‚   â”‚   â””â”€â”€ safety_manager.py   # ì•ˆì „ ê´€ë¦¬
â”‚   â”‚
â”‚   â”œâ”€â”€ alert/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ warning_system.py   # ê²½ê³  ì‹œìŠ¤í…œ
â”‚   â”‚   â””â”€â”€ audio_manager.py    # ì˜¤ë””ì˜¤ ê´€ë¦¬
â”‚   â”‚
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ config_loader.py    # ì„¤ì • ë¡œë”
â”‚       â”œâ”€â”€ logger.py           # ë¡œê¹…
â”‚       â””â”€â”€ visualization.py    # ì‹œê°í™”
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_lane_tracker.py
â”‚   â”œâ”€â”€ test_departure_detector.py
â”‚   â”œâ”€â”€ test_pid_controller.py
â”‚   â”œâ”€â”€ test_warning_system.py
â”‚   â”œâ”€â”€ test_integration.py
â”‚   â””â”€â”€ fixtures/                # í…ŒìŠ¤íŠ¸ ë°ì´í„°
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ 01_ì•„í‚¤í…ì²˜_ì„¤ê³„ì„œ.md
â”‚   â”œâ”€â”€ 02_êµ¬í˜„_ëª…ì„¸ì„œ.md      # ì´ íŒŒì¼
â”‚   â”œâ”€â”€ 03_ê²€ì¦ì„œ.md
â”‚   â”œâ”€â”€ 04_êµ¬í˜„_ì¼ì¹˜ìœ¨_ë¶„ì„.md
â”‚   â””â”€â”€ 05_ì„±ëŠ¥_í‰ê°€.md
â”‚
â”œâ”€â”€ logs/                        # ëŸ°íƒ€ì„ ë¡œê·¸
â”œâ”€â”€ checkpoints/                 # í•™ìŠµëœ íŒŒë¼ë¯¸í„°
â””â”€â”€ results/                     # í…ŒìŠ¤íŠ¸ ê²°ê³¼
```

---

## 3. í•µì‹¬ í´ë˜ìŠ¤ ëª…ì„¸

### 3.1 `LaneTracker` (ì°¨ì„  ì¶”ì ê¸°)

**íŒŒì¼:** `src/tracking/lane_tracker.py`

```python
from typing import List, Tuple, Optional, Dict
import numpy as np
from shapely.geometry import LineString, Point


class LaneTracker:
    """
    ì°¨ì„  ì¤‘ì‹¬ì„  ì¶”ì  ë° ì°¨ëŸ‰ ìœ„ì¹˜ ê³„ì‚°
    
    Attributes:
        smoothing_window (int): ìŠ¤ë¬´ë”© ìœˆë„ìš° í¬ê¸°
        min_confidence (float): ìµœì†Œ ì‹ ë¢°ë„ ì„ê³„ê°’
        vehicle_position (Tuple[float, float]): ì°¨ëŸ‰ ì¤‘ì‹¬ ìœ„ì¹˜ (ì´ë¯¸ì§€ ì¢Œí‘œ)
        image_shape (Tuple[int, int]): ì´ë¯¸ì§€ í¬ê¸° (H, W)
    """
    
    def __init__(
        self,
        smoothing_window: int = 5,
        min_confidence: float = 0.5,
        vehicle_position: Optional[Tuple[float, float]] = None,
        image_shape: Tuple[int, int] = (480, 640)
    ):
        """
        Parameters:
            smoothing_window: Moving average window size
            min_confidence: Minimum confidence threshold
            vehicle_position: Vehicle center position in image coordinates
                             Default: (image_height * 0.9, image_width / 2)
            image_shape: Image dimensions (height, width)
        """
        self.smoothing_window = smoothing_window
        self.min_confidence = min_confidence
        self.image_shape = image_shape
        
        if vehicle_position is None:
            # ê¸°ë³¸: ì´ë¯¸ì§€ í•˜ë‹¨ ì¤‘ì•™
            self.vehicle_position = (
                image_shape[0] * 0.9,
                image_shape[1] / 2
            )
        else:
            self.vehicle_position = vehicle_position
        
        # ë‚´ë¶€ ìƒíƒœ
        self._history: List[Dict] = []
        self._max_history = 30
    
    def track(
        self,
        lane_polyline: List[Tuple[float, float]],
        confidence: float
    ) -> Dict:
        """
        ì°¨ì„  ì¶”ì  ìˆ˜í–‰
        
        Parameters:
            lane_polyline: Lane centerline points [(x1,y1), (x2,y2), ...]
            confidence: Detection confidence (0.0 ~ 1.0)
        
        Returns:
            {
                "lane_center": List[Tuple[float, float]],
                "lateral_offset": float,  # meters
                "heading_error": float,   # degrees
                "curvature": float,       # 1/m
                "is_valid": bool,
                "confidence": float
            }
        """
        # 1. ìœ íš¨ì„± ê²€ì‚¬
        if confidence < self.min_confidence:
            return self._invalid_result("Low confidence")
        
        if len(lane_polyline) < 3:
            return self._invalid_result("Insufficient points")
        
        # 2. ìŠ¤ë¬´ë”©
        smoothed_polyline = self._smooth_polyline(lane_polyline)
        
        # 3. ì°¨ëŸ‰ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
        nearest_point, nearest_idx = self._find_nearest_point(
            smoothed_polyline,
            self.vehicle_position
        )
        
        # 4. íš¡ë°©í–¥ ì˜¤í”„ì…‹ ê³„ì‚° (í”½ì…€ â†’ ë¯¸í„°)
        lateral_offset_px = self._calculate_lateral_offset(
            self.vehicle_position,
            nearest_point,
            smoothed_polyline,
            nearest_idx
        )
        lateral_offset_m = self._pixel_to_meter(lateral_offset_px)
        
        # 5. í—¤ë”© ì˜¤ì°¨ ê³„ì‚°
        heading_error = self._calculate_heading_error(
            smoothed_polyline,
            nearest_idx,
            self.vehicle_position
        )
        
        # 6. ê³¡ë¥  ê³„ì‚°
        curvature = self._calculate_curvature(
            smoothed_polyline,
            nearest_idx
        )
        
        result = {
            "lane_center": smoothed_polyline,
            "lateral_offset": lateral_offset_m,
            "heading_error": heading_error,
            "curvature": curvature,
            "is_valid": True,
            "confidence": confidence,
            "nearest_point": nearest_point,
            "nearest_idx": nearest_idx
        }
        
        # íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
        self._update_history(result)
        
        return result
    
    def _smooth_polyline(
        self,
        polyline: List[Tuple[float, float]]
    ) -> List[Tuple[float, float]]:
        """
        Moving averageë¡œ polyline ìŠ¤ë¬´ë”©
        """
        if len(polyline) < self.smoothing_window:
            return polyline
        
        smoothed = []
        half_window = self.smoothing_window // 2
        
        for i in range(len(polyline)):
            start = max(0, i - half_window)
            end = min(len(polyline), i + half_window + 1)
            
            window = polyline[start:end]
            avg_x = np.mean([p[0] for p in window])
            avg_y = np.mean([p[1] for p in window])
            smoothed.append((avg_x, avg_y))
        
        return smoothed
    
    def _find_nearest_point(
        self,
        polyline: List[Tuple[float, float]],
        reference: Tuple[float, float]
    ) -> Tuple[Tuple[float, float], int]:
        """
        Polylineì—ì„œ referenceì— ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
        
        Returns:
            (nearest_point, index)
        """
        min_dist = float('inf')
        nearest_point = polyline[0]
        nearest_idx = 0
        
        for i, point in enumerate(polyline):
            dist = np.hypot(point[0] - reference[0], point[1] - reference[1])
            if dist < min_dist:
                min_dist = dist
                nearest_point = point
                nearest_idx = i
        
        return nearest_point, nearest_idx
    
    def _calculate_lateral_offset(
        self,
        vehicle_pos: Tuple[float, float],
        nearest_point: Tuple[float, float],
        polyline: List[Tuple[float, float]],
        nearest_idx: int
    ) -> float:
        """
        íš¡ë°©í–¥ ì˜¤í”„ì…‹ ê³„ì‚° (í”½ì…€ ë‹¨ìœ„)
        
        ì–‘ìˆ˜: ì°¨ì„  ì¤‘ì‹¬ ì˜¤ë¥¸ìª½
        ìŒìˆ˜: ì°¨ì„  ì¤‘ì‹¬ ì™¼ìª½
        """
        # ë²¡í„°: nearest_point â†’ vehicle_pos
        dx = vehicle_pos[0] - nearest_point[0]
        dy = vehicle_pos[1] - nearest_point[1]
        
        # ì°¨ì„  ë°©í–¥ ë²¡í„° (tangent)
        if nearest_idx < len(polyline) - 1:
            next_point = polyline[nearest_idx + 1]
        else:
            next_point = polyline[nearest_idx]
        
        tx = next_point[0] - nearest_point[0]
        ty = next_point[1] - nearest_point[1]
        t_norm = np.hypot(tx, ty)
        
        if t_norm < 1e-6:
            return 0.0
        
        # ì •ê·œí™”
        tx /= t_norm
        ty /= t_norm
        
        # Cross product (2D)ë¡œ ë¶€í˜¸ ê²°ì •
        # lateral_offset = dx * (-ty) + dy * tx
        lateral_offset = dx * (-ty) + dy * tx
        
        return lateral_offset
    
    def _calculate_heading_error(
        self,
        polyline: List[Tuple[float, float]],
        nearest_idx: int,
        vehicle_pos: Tuple[float, float]
    ) -> float:
        """
        í—¤ë”© ì˜¤ì°¨ ê³„ì‚° (degree)
        
        ì°¨ëŸ‰ headingê³¼ ì°¨ì„  tangentì˜ ê°ë„ ì°¨ì´
        ì–‘ìˆ˜: ì°¨ì„  ëŒ€ë¹„ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê¸°ìš¸ì–´ì§
        ìŒìˆ˜: ì°¨ì„  ëŒ€ë¹„ ì™¼ìª½ìœ¼ë¡œ ê¸°ìš¸ì–´ì§
        """
        # ì°¨ì„  tangent
        if nearest_idx < len(polyline) - 1:
            p1 = polyline[nearest_idx]
            p2 = polyline[nearest_idx + 1]
        else:
            return 0.0
        
        lane_angle = np.arctan2(p2[1] - p1[1], p2[0] - p1[0])
        
        # ì°¨ëŸ‰ heading (ê°€ì •: ì´ë¯¸ì§€ ìƒë‹¨ ë°©í–¥ = 0ë„)
        # ì‹¤ì œ êµ¬í˜„ ì‹œ IMU/Gyro ë°ì´í„° í™œìš©
        vehicle_angle = -np.pi / 2  # ì„ì‹œ: ìœ„ìª½ ë°©í–¥
        
        # ê°ë„ ì°¨ì´
        error_rad = vehicle_angle - lane_angle
        
        # -Ï€ ~ Ï€ ë²”ìœ„ë¡œ ì •ê·œí™”
        error_rad = np.arctan2(np.sin(error_rad), np.cos(error_rad))
        
        # degreeë¡œ ë³€í™˜
        error_deg = np.degrees(error_rad)
        
        return error_deg
    
    def _calculate_curvature(
        self,
        polyline: List[Tuple[float, float]],
        center_idx: int,
        window: int = 5
    ) -> float:
        """
        ê³¡ë¥  ê³„ì‚° (1/m)
        
        3ì ì„ ì´ìš©í•œ ê³¡ë¥  ê·¼ì‚¬
        """
        if center_idx < window or center_idx >= len(polyline) - window:
            return 0.0
        
        # 3ê°œ ì  ì„ íƒ
        p1 = polyline[center_idx - window]
        p2 = polyline[center_idx]
        p3 = polyline[center_idx + window]
        
        # ì‚¼ê°í˜• ë„“ì´ë¡œ ê³¡ë¥  ê·¼ì‚¬
        # ì°¸ê³ : https://en.wikipedia.org/wiki/Menger_curvature
        a = np.hypot(p2[0] - p1[0], p2[1] - p1[1])
        b = np.hypot(p3[0] - p2[0], p3[1] - p2[1])
        c = np.hypot(p3[0] - p1[0], p3[1] - p1[1])
        
        if a < 1e-6 or b < 1e-6 or c < 1e-6:
            return 0.0
        
        # Heron's formulaë¡œ ë„“ì´ ê³„ì‚°
        s = (a + b + c) / 2
        area = np.sqrt(max(0, s * (s - a) * (s - b) * (s - c)))
        
        # ê³¡ë¥  = 4 * Area / (a * b * c)
        curvature_px = 4 * area / (a * b * c + 1e-10)
        
        # í”½ì…€ â†’ ë¯¸í„° ë³€í™˜ (ê·¼ì‚¬)
        curvature_m = curvature_px * self._get_pixel_to_meter_ratio()
        
        return curvature_m
    
    def _pixel_to_meter(self, pixel_value: float) -> float:
        """
        í”½ì…€ ê°’ì„ ë¯¸í„°ë¡œ ë³€í™˜
        
        ê°€ì •: ì°¨ì„  í­ = 3.5m, ì´ë¯¸ì§€ í­ = 640px
        ì‹¤ì œë¡œëŠ” ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í•„ìš”
        """
        # ê°„ë‹¨í•œ ì„ í˜• ê·¼ì‚¬
        # ì‹¤ì œë¡œëŠ” IPM (Inverse Perspective Mapping) ì‚¬ìš©
        lane_width_m = 3.5
        lane_width_px = self.image_shape[1] * 0.3  # ê°€ì •: ì°¨ì„ ì´ ì´ë¯¸ì§€ í­ì˜ 30%
        
        ratio = lane_width_m / lane_width_px
        return pixel_value * ratio
    
    def _get_pixel_to_meter_ratio(self) -> float:
        """í”½ì…€-ë¯¸í„° ë³€í™˜ ë¹„ìœ¨"""
        lane_width_m = 3.5
        lane_width_px = self.image_shape[1] * 0.3
        return lane_width_m / lane_width_px
    
    def _invalid_result(self, reason: str) -> Dict:
        """Invalid ê²°ê³¼ ë°˜í™˜"""
        return {
            "lane_center": [],
            "lateral_offset": 0.0,
            "heading_error": 0.0,
            "curvature": 0.0,
            "is_valid": False,
            "confidence": 0.0,
            "reason": reason
        }
    
    def _update_history(self, result: Dict):
        """íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸"""
        self._history.append(result)
        if len(self._history) > self._max_history:
            self._history.pop(0)
    
    def get_history(self) -> List[Dict]:
        """íˆìŠ¤í† ë¦¬ ë°˜í™˜"""
        return self._history.copy()
    
    def reset(self):
        """ìƒíƒœ ì´ˆê¸°í™”"""
        self._history.clear()
```

### 3.2 `DepartureDetector` (ì´íƒˆ ê°ì§€ê¸°)

**íŒŒì¼:** `src/detection/departure_detector.py`

```python
from typing import Dict, Tuple
import numpy as np
from dataclasses import dataclass


@dataclass
class DepartureThresholds:
    """ì´íƒˆ íŒì • ì„ê³„ê°’"""
    level_2_offset: float = 0.4  # meters
    level_3_offset: float = 0.6
    level_4_offset: float = 0.8
    level_5_offset: float = 1.0
    
    level_2_heading: float = 5.0  # degrees
    level_3_heading: float = 10.0
    level_4_heading: float = 15.0
    level_5_heading: float = 20.0


class DepartureDetector:
    """
    ì°¨ì„  ì´íƒˆ ê°ì§€ ë° ìœ„í—˜ë„ í‰ê°€
    
    Risk Levels:
        0: Safe - ì •ìƒ ì£¼í–‰
        1: Normal - ì•½ê°„ ë²—ì–´ë‚¨, ëª¨ë‹ˆí„°ë§
        2: Caution - ì£¼ì˜ í•„ìš”, ì‹œê° ê²½ê³ 
        3: Warning - ê²½ê³  í•„ìš”, ì²­ê° ê²½ê³ 
        4: Critical - ìœ„í—˜, í–…í‹± ê²½ê³  + ê°œì… ì¤€ë¹„
        5: Emergency - ê¸´ê¸‰, ì¦‰ì‹œ ê°œì…
    """
    
    def __init__(
        self,
        thresholds: DepartureThresholds = None,
        lane_width: float = 3.5
    ):
        """
        Parameters:
            thresholds: ì´íƒˆ íŒì • ì„ê³„ê°’
            lane_width: ì°¨ì„  í­ (meters)
        """
        self.thresholds = thresholds or DepartureThresholds()
        self.lane_width = lane_width
        
        # ìƒíƒœ
        self._prev_risk_level = 0
        self._risk_start_time = None
    
    def detect(
        self,
        lateral_offset: float,
        heading_error: float,
        vehicle_speed: float,
        timestamp: float
    ) -> Dict:
        """
        ì´íƒˆ ê°ì§€ ìˆ˜í–‰
        
        Parameters:
            lateral_offset: íš¡ë°©í–¥ ì˜¤í”„ì…‹ (meters)
            heading_error: í—¤ë”© ì˜¤ì°¨ (degrees)
            vehicle_speed: ì°¨ëŸ‰ ì†ë„ (km/h)
            timestamp: í˜„ì¬ ì‹œê° (Unix timestamp)
        
        Returns:
            {
                "is_departing": bool,
                "risk_level": int,  # 0-5
                "time_to_crossing": float,  # seconds
                "departure_side": str,  # "left", "right", "none"
                "confidence": float
            }
        """
        # 1. ìœ„í—˜ë„ ë ˆë²¨ ê²°ì •
        risk_level = self._calculate_risk_level(
            abs(lateral_offset),
            abs(heading_error)
        )
        
        # 2. ì´íƒˆ ë°©í–¥
        departure_side = self._determine_side(lateral_offset)
        
        # 3. Time To Crossing ê³„ì‚°
        ttc = self._calculate_ttc(
            lateral_offset,
            heading_error,
            vehicle_speed
        )
        
        # 4. ì´íƒˆ ì—¬ë¶€
        is_departing = risk_level >= 2
        
        # 5. ì‹ ë¢°ë„ (ê°„ë‹¨í•œ íœ´ë¦¬ìŠ¤í‹±)
        confidence = min(1.0, risk_level / 5.0)
        
        result = {
            "is_departing": is_departing,
            "risk_level": risk_level,
            "time_to_crossing": ttc,
            "departure_side": departure_side,
            "confidence": confidence,
            "timestamp": timestamp
        }
        
        # ìƒíƒœ ì—…ë°ì´íŠ¸
        self._update_state(risk_level, timestamp)
        
        return result
    
    def _calculate_risk_level(
        self,
        abs_offset: float,
        abs_heading: float
    ) -> int:
        """
        ìœ„í—˜ë„ ë ˆë²¨ ê³„ì‚°
        
        offsetê³¼ heading ì¤‘ ë” ë†’ì€ ë ˆë²¨ ì„ íƒ
        """
        # Offset ê¸°ë°˜ ë ˆë²¨
        if abs_offset >= self.thresholds.level_5_offset:
            offset_level = 5
        elif abs_offset >= self.thresholds.level_4_offset:
            offset_level = 4
        elif abs_offset >= self.thresholds.level_3_offset:
            offset_level = 3
        elif abs_offset >= self.thresholds.level_2_offset:
            offset_level = 2
        else:
            offset_level = 0
        
        # Heading ê¸°ë°˜ ë ˆë²¨
        if abs_heading >= self.thresholds.level_5_heading:
            heading_level = 5
        elif abs_heading >= self.thresholds.level_4_heading:
            heading_level = 4
        elif abs_heading >= self.thresholds.level_3_heading:
            heading_level = 3
        elif abs_heading >= self.thresholds.level_2_heading:
            heading_level = 2
        else:
            heading_level = 0
        
        # ìµœëŒ€ê°’ ì„ íƒ
        return max(offset_level, heading_level)
    
    def _determine_side(self, lateral_offset: float) -> str:
        """ì´íƒˆ ë°©í–¥ ê²°ì •"""
        if lateral_offset > 0.1:
            return "right"
        elif lateral_offset < -0.1:
            return "left"
        else:
            return "none"
    
    def _calculate_ttc(
        self,
        lateral_offset: float,
        heading_error: float,
        vehicle_speed: float
    ) -> float:
        """
        Time To Crossing ê³„ì‚°
        
        ì°¨ì„  ê²½ê³„ê¹Œì§€ ë„ë‹¬í•˜ëŠ” ì‹œê°„ ì¶”ì •
        """
        # ì†ë„ê°€ ë„ˆë¬´ ë‚®ìœ¼ë©´ TTC ë¬´í•œëŒ€
        if vehicle_speed < 5.0:  # 5 km/h
            return float('inf')
        
        # ì°¨ì„  ê²½ê³„ê¹Œì§€ ë‚¨ì€ ê±°ë¦¬
        remaining_distance = (self.lane_width / 2) - abs(lateral_offset)
        
        if remaining_distance <= 0:
            return 0.0
        
        # íš¡ë°©í–¥ ì†ë„ ì¶”ì • (ê°„ë‹¨í•œ ê·¼ì‚¬)
        # lateral_velocity â‰ˆ vehicle_speed * sin(heading_error)
        vehicle_speed_ms = vehicle_speed / 3.6  # km/h â†’ m/s
        heading_rad = np.radians(heading_error)
        lateral_velocity = abs(vehicle_speed_ms * np.sin(heading_rad))
        
        if lateral_velocity < 0.01:
            return float('inf')
        
        ttc = remaining_distance / lateral_velocity
        
        return min(ttc, 10.0)  # ìµœëŒ€ 10ì´ˆë¡œ ì œí•œ
    
    def _update_state(self, risk_level: int, timestamp: float):
        """ë‚´ë¶€ ìƒíƒœ ì—…ë°ì´íŠ¸"""
        if risk_level != self._prev_risk_level:
            self._risk_start_time = timestamp
        
        self._prev_risk_level = risk_level
    
    def reset(self):
        """ìƒíƒœ ì´ˆê¸°í™”"""
        self._prev_risk_level = 0
        self._risk_start_time = None
```

### 3.3 `PIDController` (PID ì œì–´ê¸°)

**íŒŒì¼:** `src/control/pid_controller.py`

```python
from typing import Optional
import numpy as np
from dataclasses import dataclass


@dataclass
class PIDParams:
    """PID íŒŒë¼ë¯¸í„°"""
    kp: float = 0.5
    ki: float = 0.1
    kd: float = 0.2
    k_heading: float = 0.3
    
    max_steering_angle: float = 30.0  # degrees
    max_steering_rate: float = 5.0    # deg/s
    
    windup_limit: float = 10.0  # Anti-windup


class PIDController:
    """
    PID ê¸°ë°˜ ì¡°í–¥ ì œì–´ê¸°
    
    Control Law:
        u(t) = Kp * e(t) + Ki * âˆ«e(t)dt + Kd * de(t)/dt
        
        where:
            e(t) = lateral_offset + K_heading * heading_error
    """
    
    def __init__(self, params: PIDParams = None, dt: float = 0.05):
        """
        Parameters:
            params: PID íŒŒë¼ë¯¸í„°
            dt: ì œì–´ ì£¼ê¸° (seconds)
        """
        self.params = params or PIDParams()
        self.dt = dt
        
        # ë‚´ë¶€ ìƒíƒœ
        self._integral = 0.0
        self._prev_error = 0.0
        self._prev_steering = 0.0
    
    def compute(
        self,
        lateral_offset: float,
        heading_error: float,
        curvature: float = 0.0
    ) -> float:
        """
        ì œì–´ ì‹ í˜¸ ê³„ì‚°
        
        Parameters:
            lateral_offset: íš¡ë°©í–¥ ì˜¤í”„ì…‹ (meters)
            heading_error: í—¤ë”© ì˜¤ì°¨ (degrees)
            curvature: ì°¨ì„  ê³¡ë¥  (1/m)
        
        Returns:
            steering_angle: ì¡°í–¥ê° (degrees)
        """
        # 1. í†µí•© ì—ëŸ¬ ê³„ì‚°
        error = lateral_offset + self.params.k_heading * heading_error
        
        # 2. PID í•­ ê³„ì‚°
        # P term
        p_term = self.params.kp * error
        
        # I term (with anti-windup)
        self._integral += error * self.dt
        self._integral = np.clip(
            self._integral,
            -self.params.windup_limit,
            self.params.windup_limit
        )
        i_term = self.params.ki * self._integral
        
        # D term
        derivative = (error - self._prev_error) / self.dt
        d_term = self.params.kd * derivative
        
        # 3. Feedforward term (ê³¡ë¥  ë³´ìƒ)
        ff_term = np.degrees(np.arctan(curvature * 2.5))  # wheelbase = 2.5m ê°€ì •
        
        # 4. ì´ ì œì–´ ì‹ í˜¸
        steering_raw = p_term + i_term + d_term + ff_term
        
        # 5. ì œì•½ ì¡°ê±´ ì ìš©
        # ìµœëŒ€ ì¡°í–¥ê° ì œí•œ
        steering_clamped = np.clip(
            steering_raw,
            -self.params.max_steering_angle,
            self.params.max_steering_angle
        )
        
        # ìµœëŒ€ ì¡°í–¥ ì†ë„ ì œí•œ
        steering_rate = (steering_clamped - self._prev_steering) / self.dt
        if abs(steering_rate) > self.params.max_steering_rate:
            steering_rate = np.sign(steering_rate) * self.params.max_steering_rate
            steering_clamped = self._prev_steering + steering_rate * self.dt
        
        # 6. ìƒíƒœ ì—…ë°ì´íŠ¸
        self._prev_error = error
        self._prev_steering = steering_clamped
        
        return steering_clamped
    
    def reset(self):
        """ì œì–´ê¸° ìƒíƒœ ì´ˆê¸°í™”"""
        self._integral = 0.0
        self._prev_error = 0.0
        self._prev_steering = 0.0
    
    def update_params(self, **kwargs):
        """íŒŒë¼ë¯¸í„° ë™ì  ì—…ë°ì´íŠ¸"""
        for key, value in kwargs.items():
            if hasattr(self.params, key):
                setattr(self.params, key, value)
```

---

*(ê³„ì† ì‘ì„± ì¤‘... íŒŒì¼ì´ ë„ˆë¬´ ê¸¸ì–´ì ¸ì„œ ì¼ë¶€ë§Œ ë³´ì—¬ë“œë¦½ë‹ˆë‹¤)*

ì´ì œ ê²€ì¦ì„œë„ ì‘ì„±í• ê¹Œìš”? ì•„ë‹ˆë©´ ë¨¼ì € ì´ êµ¬í˜„ ëª…ì„¸ì„œë¥¼ ì™„ì„±í•˜ê³  ì‹¤ì œ ì½”ë“œ êµ¬í˜„ì„ ì‹œì‘í• ê¹Œìš”?